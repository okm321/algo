# ABC301 B問題 解説 - 数列の補完

## 数列とは？

数列とは、**数字が順番に並んでいるもの**のことです。

### 身近な数列の例
- 1, 2, 3, 4, 5（1ずつ増える）
- 2, 4, 6, 8, 10（2ずつ増える）  
- 10, 7, 4, 1（3ずつ減る）

これらはすべて数列です！規則的に並んでいる数字の列だと思ってください。

## 問題の内容

この問題では、「飛び飛びの数列を、隣り合う数の差が1になるように埋める」ことが求められています。

### 具体例で理解しよう

**入力例1: [2, 5, 1, 2]**

1. まず2と5を見ます → 差が3あります（5-2=3）
2. 間に3, 4を入れます → [2, 3, 4, 5, 1, 2]
3. 次に5と1を見ます → 差が4あります（5-1=4）  
4. 5から1に向かって降りていくので、4, 3, 2を入れます → [2, 3, 4, 5, 4, 3, 2, 1, 2]
5. 最後の1と2は差が1なのでOK！

## 解法のポイント

1. **隣り合う2つの数を順番に見ていく**
2. **差が1より大きい場合は間を埋める**
   - 小さい方から大きい方へ：1ずつ増やしながら埋める
   - 大きい方から小さい方へ：1ずつ減らしながら埋める
3. **すべての隣り合う数の差が1になるまで繰り返す**

## Goでの実装方法

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
)

func main() {
    scanner := bufio.NewScanner(os.Stdin)
    
    // Nを読み込む
    scanner.Scan()
    n, _ := strconv.Atoi(scanner.Text())
    
    // 数列Aを読み込む
    scanner.Scan()
    parts := strings.Split(scanner.Text(), " ")
    a := make([]int, n)
    for i := 0; i < n; i++ {
        a[i], _ = strconv.Atoi(parts[i])
    }
    
    // 結果を格納するスライス
    result := []int{a[0]} // 最初の要素は必ず入れる
    
    // 隣り合う要素を見ていく
    for i := 1; i < n; i++ {
        prev := a[i-1]
        curr := a[i]
        
        // 差が1より大きい場合は間を埋める
        if prev < curr {
            // 昇順で埋める
            for j := prev + 1; j < curr; j++ {
                result = append(result, j)
            }
        } else if prev > curr {
            // 降順で埋める
            for j := prev - 1; j > curr; j-- {
                result = append(result, j)
            }
        }
        
        // 現在の要素を追加
        result = append(result, curr)
    }
    
    // 結果を出力
    for i, v := range result {
        if i > 0 {
            fmt.Print(" ")
        }
        fmt.Print(v)
    }
    fmt.Println()
}
```

## なぜこの解法で動くの？

1. **左から順番に処理していく**ことで、すでに処理した部分は触らないので安全
2. **隣り合う数の間を埋める**だけなので、シンプルで間違いにくい
3. **昇順・降順の両方に対応**しているので、どんな数列でも処理できる

## まとめ

数列は「数字の並び」で、この問題では「隣り合う数の差を1にする」ことが目標でした。
プログラミングでは、配列（スライス）を使って数列を表現し、ループで順番に処理していくのが基本です！