# ABC302 B問題 C++解法のGo実装と詳細解説

## C++コードの処理フローを理解する

### 1. 初期設定とデータ構造

```go
// 8方向の移動量を定義
dx := []int{-1, -1, -1, 0, 0, 1, 1, 1}
dy := []int{-1, 0, 1, -1, 1, -1, 0, 1}
```

この配列で8方向への移動を表現しています：
```
インデックス0: (-1,-1) → 左上
インデックス1: (-1, 0) → 上
インデックス2: (-1, 1) → 右上
インデックス3: ( 0,-1) → 左
インデックス4: ( 0, 1) → 右
インデックス5: ( 1,-1) → 左下
インデックス6: ( 1, 0) → 下
インデックス7: ( 1, 1) → 右下
```

### 2. 4重ループの構造と処理の流れ

```go
for i := 0; i < H; i++ {           // ①各行を走査
    for j := 0; j < W; j++ {       // ②各列を走査
        for k := 0; k < 8; k++ {   // ③8方向それぞれを試す
            str := ""
            for t := 0; t < 5; t++ { // ④5文字分を取得
```

#### 具体例で理解する（5×8のグリッドで(2,1)から右方向の場合）

```
グリッド:
0 1 2 3 4 5 6 7
a b c d e f g h  (0行目)
i s n u k e p q  (1行目)
r s t u v w x y  (2行目) ← i=2, j=1からスタート
z a b c d e f g  (3行目)
h i j k l m n o  (4行目)
```

1. **i=2, j=1**：(2,1)の's'から開始
2. **k=4**：右方向（dx[4]=0, dy[4]=1）を選択
3. **t=0～4のループ**：
   - t=0: x=2+0×0=2, y=1+0×1=1 → grid[2][1]='s'
   - t=1: x=2+1×0=2, y=1+1×1=2 → grid[2][2]='t'
   - t=2: x=2+2×0=2, y=1+2×1=3 → grid[2][3]='u'
   - t=3: x=2+3×0=2, y=1+3×1=4 → grid[2][4]='v'
   - t=4: x=2+4×0=2, y=1+4×1=5 → grid[2][5]='w'
   - 結果：str = "stuvw" ≠ "snuke"

### 3. 境界チェックの重要性

```go
if x < 0 || x >= H || y < 0 || y >= W {
    break
}
```

例：(0,0)から左上方向に探索する場合
- t=0: x=0+0×(-1)=0, y=0+0×(-1)=0 → OK
- t=1: x=0+1×(-1)=-1, y=0+1×(-1)=-1 → 範囲外！
- breakして次の方向へ

### 4. 文字列の構築と判定

```go
str += string(grid[x][y])
```

- C++では`str+=s[x][y]`で文字を追加
- Goでは`grid[x]`は文字列、`grid[x][y]`はbyteなので`string()`で変換

### 5. 見つかった場合の出力処理

```go
if str == "snuke" {
    for t := 0; t < 5; t++ {
        x := i + t*dx[k] + 1  // +1で1-indexedに変換
        y := j + t*dy[k] + 1
        fmt.Fprintln(w, x, y)
    }
    return
}
```

**なぜ+1するのか？**
- 配列のインデックスは0から始まる（0-indexed）
- 問題の出力は1から始まる（1-indexed）
- 例：配列の[0][0]は、出力では(1,1)

## 完全な処理の流れ（サンプル入力1の場合）

```
入力:
6 6
v k x j z p
h e l l o x
s n u k e j
x x x x x x
x x x x x x
o x x x x x
```

1. (0,0)の'v'から8方向探索 → 見つからない
2. (0,1)の'k'から8方向探索 → 見つからない
3. ...続く...
4. (2,0)の's'から：
   - 上方向：見つからない
   - 右方向：s,n,u,k,e → **見つかった！**
5. 座標を出力：
   - (3,1), (3,2), (3,3), (3,4), (3,5)

## GoとC++の違い

1. **文字列の扱い**
   - C++: `vector<string>`でグリッドを保持
   - Go: `[]string`でグリッドを保持

2. **文字の取得**
   - C++: `s[x][y]`で直接文字を取得
   - Go: `grid[x][y]`はbyteなので`string()`で変換

3. **出力**
   - C++: `cout<<x<<" "<<y<<endl`
   - Go: `fmt.Fprintln(w, x, y)`

## アルゴリズムの効率性

- **時間計算量**: O(H × W × 8 × 5) = O(H × W)
- **空間計算量**: O(H × W)（グリッドの保存）

各マスから最大8×5=40回の文字アクセスで済むため、制約内では十分高速です。