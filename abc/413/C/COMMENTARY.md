# ABC413 C問題 解説

## 問題の概要
クエリ処理の問題で、以下の2種類の操作を行います：
1. **クエリ1**: 配列の末尾に値xをk個追加
2. **クエリ2**: 配列の先頭からk個削除し、その合計を出力

## TLEの原因
素朴な実装では以下の問題があります：
- クエリ1で最大10^9個の要素を1つずつ追加 → O(k)の時間
- 配列の先頭から削除する際のスライス操作 → O(n)の時間

## 解法：ランレングス圧縮的なアプローチ

### 基本的な考え方
配列を実際に作るのではなく、「値」と「その個数」のペアで管理します。

```go
type Pair struct {
    value int  // 値
    count int  // その値が何個あるか
}
```

### クエリ1（追加）の処理
```go
if len(blocks) > 0 && blocks[len(blocks)-1].value == query[2] {
    // 最後のブロックと同じ値なら、個数だけ増やす
    blocks[len(blocks)-1].count += query[1]
} else {
    // 違う値なら、新しいブロックを追加
    blocks = append(blocks, Pair{value: query[2], count: query[1]})
}
```

**例：**
- 現在：`[{value: 3, count: 5}]`（3が5個）
- 「3を10個追加」→ `[{value: 3, count: 15}]`（個数だけ増やす）
- 「7を8個追加」→ `[{value: 3, count: 15}, {value: 7, count: 8}]`（新しいブロック追加）

### クエリ2（削除）の処理
先頭から必要な個数だけ削除し、合計を計算します。

```go
k := query[1]  // 削除したい個数
sum := 0       // 削除した値の合計
idx := 0       // 現在見ているブロックの位置

for k > 0 && idx < len(blocks) {
    if blocks[idx].count <= k {
        // このブロックを全部削除
        sum += blocks[idx].value * blocks[idx].count
        k -= blocks[idx].count
        idx++
    } else {
        // このブロックの一部だけ削除
        sum += blocks[idx].value * k
        blocks[idx].count -= k
        k = 0
    }
}

blocks = blocks[idx:]  // 削除済みのブロックを配列から除去
```

**処理の流れの例：**
- 現在：`[{value: 2, count: 3}, {value: 5, count: 4}, {value: 7, count: 2}]`
- 「先頭から5個削除」の場合：
  1. 1番目のブロック（2が3個）を全部削除 → sum += 2×3 = 6、残り削除数 = 5-3 = 2
  2. 2番目のブロック（5が4個）から2個削除 → sum += 5×2 = 10
  3. 合計：6 + 10 = 16を出力
  4. 配列を更新：`[{value: 5, count: 2}, {value: 7, count: 2}]`

## 計算量の改善
- **追加（クエリ1）**: O(1) - 最後のブロックを確認して追加するだけ
- **削除（クエリ2）**: O(削除するブロック数) - 最悪でもブロック数分の処理

元の実装では10^9個の要素を1つずつ処理する必要がありましたが、この方法では1つのブロックとして扱えるため、大幅に高速化されます。

## ポイント
- 同じ値が連続する場合は1つのブロックにまとめる
- 削除時は必要な分だけ処理し、残りは保持する
- 削除済みのブロックは配列から除去してメモリを節約