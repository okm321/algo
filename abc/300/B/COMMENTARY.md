# AtCoder ABC300 B問題 解説

## 問題の概要

2つのH×Wのグリッド（AとB）が与えられ、Aに以下の操作を組み合わせてBと同じにできるか判定する問題です。

**操作：**
1. 縦シフト：全ての列を同時に下にシフト（一番下は一番上へ）
2. 横シフト：全ての行を同時に右にシフト（一番右は一番左へ）

## 解法の鍵：逆向きに考える

「AをBに変換できるか？」ではなく、「**Bの各マスが、元のAのどこから来たか？**」を考えます。

### 具体例（3×3グリッド）

```
元のグリッド:     1回下シフト後:
0: ABC           0: GHI (元の2行目が移動)
1: DEF    →      1: ABC (元の0行目が移動)
2: GHI           2: DEF (元の1行目が移動)
```

つまり、シフト後の位置から元の位置を逆算できます！

## 核心となる式

```go
ai := (i - s + H) % H  // 元の行番号
aj := (j - t + W) % W  // 元の列番号
```

### なぜこの式になるのか？

1. **基本的な考え方**
   - s回下シフト → 元の位置は「現在の位置 - s」
   - t回右シフト → 元の位置は「現在の位置 - t」

2. **モジュロ演算で循環を実現**
   - グリッドの端まで行ったら反対側に戻る
   - これを`% H`や`% W`で実現

3. **+Hや+Wが必要な理由**
   - `i - s`が負になる場合がある
   - 例：i=0, s=2のとき → 0-2 = -2
   - Goでは`-2 % 3 = -2`（期待値は1）
   - `(-2 + 3) % 3 = 1`で正しい値に！

## アルゴリズムの流れ

```go
for s := 0; s < H; s++ {        // 縦シフト回数を全て試す
    for t := 0; t < W; t++ {    // 横シフト回数を全て試す
        ok := true
        for i := 0; i < H; i++ {
            for j := 0; j < W; j++ {
                // B[i][j]に対応する元のAの位置を計算
                ai := (i - s + H) % H
                aj := (j - t + W) % W
                
                // 一致しなければこのパターンは違う
                if A[ai][aj] != B[i][j] {
                    ok = false
                    break
                }
            }
        }
        if ok {
            // 全マス一致！
            return "Yes"
        }
    }
}
return "No"  // どのパターンでも一致しなかった
```

## 計算量

- 時間計算量：O(H × W × H × W) = O(H²W²)
- 制約が H, W ≤ 30 なので、最大でも 30² × 30² = 810,000回程度
- 十分高速に動作します！

## まとめ

1. **シフトの逆操作**を考えることで問題を簡潔に解ける
2. **モジュロ演算**で循環を表現
3. **負の数の処理**に注意（+H, +Wを加える）
4. **全パターンを試す**総当たり法で確実に判定

この「逆向きに考える」発想は、他の問題でも役立つ重要なテクニックです！