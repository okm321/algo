# AtCoder ABC300 C問題 解説

## 🎯 問題の概要

この問題は「**バツ印（×）を探す問題**」です！

グリッド（格子状の盤面）の中から、特定の条件を満たす「バツ印」を見つけて、サイズごとに何個あるか数える問題です。

### 入力
- 縦H×横Wのグリッド
- 各マスには `#`（黒）か `.`（白）が書かれている

### 出力
- サイズ1からサイズN（Nは最大可能サイズ）までの各サイズのバツ印の個数

## 📐 バツ印の定義（これが超重要！）

### バツ印のサイズとは？

バツ印には「サイズ」があります。サイズnのバツ印は、中心から各方向にn個ずつ`#`が伸びている形です。

```
サイズ1のバツ印:     サイズ2のバツ印:     サイズ3のバツ印:
    . # .              . . # . .           . . . # . . .
    # # #              . # # # .           . . # # # . .
    . # .              # # # # #           . # # # # # .
                       . # # # .           # # # # # # #
                       . . # . .           . # # # # # .
                                          . . # # # . .
                                          . . . # . . .
```

### バツ印の3つの条件

1. **中心が`#`である**
2. **対角線上のマスが全て`#`である**
   - 左上から右下への対角線
   - 右上から左下への対角線
3. **バツ印の外側の対角線上に少なくとも1つ`.`がある**
   - これが重要！バツ印がちゃんと「終わっている」ことを確認

### 具体例で理解しよう！

```
これはサイズ1のバツ印 ✓      これはバツ印じゃない ✗
    . # .                      . # .
    # # #                      # . #  ← 中心が.なのでダメ
    . # .                      . # .

これはサイズ2のバツ印 ✓      これもバツ印じゃない ✗
    . . # . .                  # # # # #
    . # # # .                  # # # # #  ← 外側に.がないので
    # # # # #                  # # # # #    バツ印として認識されない
    . # # # .                  # # # # #
    . . # . .                  # # # # #
```

## 🔍 解法のアルゴリズム

### アルゴリズムの流れ

1. **全てのマスを調べる**
   - 各マスを「バツ印の中心候補」として考える

2. **中心が`#`かチェック**
   - `.`なら次のマスへ

3. **そのマスを中心として、どこまでバツ印が作れるか調べる**
   - サイズ1から順番に大きくしていく
   - 対角線上のマスが全て`#`か確認
   - 条件を満たさなくなったらストップ

4. **見つかったバツ印を記録**
   - どのサイズのバツ印が見つかったか記録

5. **重複を避ける**
   - 一度使ったマスは他のバツ印で使わない

### 具体的な手順の例

```
例：5×5のグリッドで考えてみよう

# # # # #
# # # # #
# # # # #
# # # # #
# # # # #

(2,2)を中心として調べる：
1. 中心は#？ → YES
2. サイズ1のバツ印になる？
   - (1,1), (1,3), (3,1), (3,3)が全て#？ → YES
   - 外側に.がある？ → NO（全部#だから）
3. サイズ2のバツ印になる？
   - (0,0), (0,4), (4,0), (4,4)が全て#？ → YES
   - 外側に.がある？ → NO（グリッドの外だから）
   
→ このマスを中心としたバツ印は見つからない
```

## 💡 実装のポイント

### 1. バツ印のサイズを決める関数の考え方

```go
func getCrossSize(grid [][]rune, h, w, i, j int) int {
    // 中心が'.'なら0を返す
    if grid[i][j] == '.' {
        return 0
    }
    
    // 最大可能サイズを計算（中心から端までの最短距離）
    maxSize := min(min(i, j), min(h-1-i, w-1-j))
    
    // サイズ1から順番に試す
    for n := 1; n <= maxSize; n++ {
        // 4方向全てチェック
        allSharp := true
        for k := 1; k <= n; k++ {
            if grid[i-k][j-k] != '#' || // 左上
               grid[i-k][j+k] != '#' || // 右上
               grid[i+k][j-k] != '#' || // 左下
               grid[i+k][j+k] != '#' {  // 右下
                allSharp = false
                break
            }
        }
        
        if !allSharp {
            return n - 1  // 前のサイズまでがバツ印
        }
    }
    
    return maxSize
}
```

### 2. 使用済みマスの管理

バツ印は重複してはいけないので、一度使ったマスは記録しておく必要があります。

```go
// 使用済みマスを記録
used := make([][]bool, h)
for i := range used {
    used[i] = make([]bool, w)
}

// バツ印のマスを使用済みにする
func markUsed(used [][]bool, i, j, size int) {
    used[i][j] = true  // 中心
    for k := 1; k <= size; k++ {
        used[i-k][j-k] = true  // 左上
        used[i-k][j+k] = true  // 右上
        used[i+k][j-k] = true  // 左下
        used[i+k][j+k] = true  // 右下
    }
}
```

### 3. よくある間違いと注意点

1. **外側の`.`チェックを忘れる**
   - バツ印は必ず`.`で囲まれている必要がある！
   - グリッドの端にあるバツ印は、外側がグリッドの外になるので条件を満たす

2. **重複カウント**
   - 一度使ったマスを別のバツ印で再利用してしまう
   - 使用済みフラグをしっかり管理する

3. **配列の範囲外アクセス**
   - グリッドの端でバツ印を探すときは範囲チェックが重要
   - 最大サイズの計算で防げる

## 🎓 まとめ

この問題のポイントは：
1. バツ印の定義を正確に理解する（特に外側の`.`の条件）
2. 各マスを中心として、作れる最大のバツ印を見つける
3. 使用済みマスを管理して重複を避ける

初心者の方は、まず小さなグリッドで手で追いかけてみると理解しやすいですよ！